Midiendo un robot 
Es difícil comparar objetivamente robots simplemente dejándolos resolver algunos escenarios. Tal vez un robot acaba de conseguir tareas más fáciles, o el tipo de tareas en las que es bueno, mientras que el otro no. Escribe una función compararRobots que toma dos robots (y su memoria de inicio). Debe generar 100 tareas y dejar que cada uno de los robots resuelvan cada una de estas tareas. Cuando terminen, debería generar el promedio de pasos que cada robot tomó por tarea. En favor de lo que es justo, asegúrate de la misma tarea a ambos robots, en lugar de generar diferentes tareas por robot.

Eficiencia del robot 
Puedes escribir un robot que termine la tarea de entrega más rápido que robotOrientadoAMetas? Si observas el comportamiento de ese robot, qué obviamente cosas estúpidas este hace? Cómo podrían mejorarse? Si resolviste el ejercicio anterior, es posible que desees utilizar tu función compararRobots para verificar si has mejorado al robot.

Conjunto persistente 
La mayoría de las estructuras de datos proporcionadas en un entorno de JavaScript estándar no son muy adecuadas para usos persistentes. Los arrays tienen los métodos slice y concat, que nos permiten fácilmente crear nuevos arrays sin dañar al anterior. Pero Set, por ejemplo, no tiene métodos para crear un nuevo conjunto con un elemento agregado o eliminado. Escribe una nueva clase ConjuntoP, similar a la clase Conjunto del Capitulo 6, que almacena un conjunto de valores. Como Grupo, tiene métodos añadir, eliminar, y tiene. Su método añadir, sin embargo, debería retornar una nueva instancia de ConjuntoP con el miembro dado agregado, y dejar la instancia anterior sin cambios. Del mismo modo, eliminar crea una nueva instancia sin un miembro dado.
La clase debería funcionar para valores de cualquier tipo, no solo strings. Esta no tiene que ser eficiente cuando se usa con grandes cantidades de valores. El constructor no deberia ser parte de la interfaz de la clase (aunque definitivamente querrás usarlo internamente). En cambio, allí hay una instancia vacía, ConjuntoP.vacio, que se puede usar como un valor de inicio. Por qué solo necesitas un valor ConjuntoP.vacio, en lugar de tener una función que crea un nuevo mapa vacío cada vez?